function [sol info] = polysolve_sh(eq,act_mon,varargin)

method = 'qr';
order = 'grevlex';
red_elim = 'none';
basis_selection = 'none';
template_file = [];
basis = [];
dim = [];

for i=1:2:length(varargin)
	switch varargin{i}
		case 'method', method = varargin{i+1};
		case 'order', order = varargin{i+1};
		case 'basis', basis = varargin{i+1};
		case 'dim', dim = varargin{i+1};
		case 'red_elim', red_elim = varargin{i+1};
		case 'basis_sel', basis_selection = varargin{i+1};
		case 'save_template', template_file = varargin{i+1};
		otherwise, error('Parameter parse error');
	end
end

if isempty(dim)
% 	error('Specify "dim" as the expected number of solutions');
end

eq = eqsize(eq(:));
n = nvars(eq(1));
% x = create_vars(n);


% Find permissible basis monomials
[C M] = polynomials2matrix(eq,order);
% C = bsxfun(@rdivide,C,sqrt(sum(C.^2,2)));
fprintf('%u equations, %u monomials\n',size(C));
[~,ia] = intersect(act_mon*M,M);
P = M(ia);
% sym(P')
fprintf('%u permissible monomials\n',numel(P));
% select basis among permissible
% B = P(randperm(numel(P),bsize));
% B = union(B,P(end-bsize+1:end));
if isa(basis,'multipol')
	B = intersect(M,basis);
	fprintf('%u of %u selected basis monomials appear in the equations\n',numel(B),numel(basis));
	B = intersect(P,B);
	fprintf('%u basis monomials belong to the permissible set\n',numel(B));
% 	sym(setdiff(basis,B))
elseif isnumeric(basis) && ~isempty(basis)
	B = P(end-basis+1:end);
else
	error('Specify "basis" as a vector of monomials or an integer indicating the basis size');
end
fprintf('%u basis monomials selected\n',numel(B));
if numel(B)<dim
% 	warning('Basis size should be >= dim');
end

R = setdiff(act_mon*B,B);
[~,iR] = intersect(M,R);
[~,iB] = intersect(M,B);
iE = setdiff(1:numel(M),[iR iB]);

dE = length(iE);
dB = length(iB);
dR = length(iR);
fprintf('%u excessive, %u reduction monomials\n',dE,dR);

C = C(:,[iE iR iB]);

% Save template pattern. The coefficients of the input equations should then be consecutive integers as
% generated by [eqs ind] = geneq(eq,...)
if ~isempty(template_file)
	fid = fopen(template_file,'w+');
	[indi indj val] = find(C);
	fprintf(fid,'r = [');
	for i=1:length(indi), fprintf(fid,'%d ',indi(i)); end
	fprintf(fid,'];\nc = [');
	for i=1:length(indj), fprintf(fid,'%d ',indj(i)); end
	fprintf(fid,'];\nv = [');
	for i=1:length(val), fprintf(fid,'%d ',val(i)); end
	fprintf(fid,'];\n');
	fclose(fid);
% 	save('debug2.mat','indi','indj','val');
% 	Ccheck = sparse(indi,indj,val);
% 	max(abs(C-Ccheck))
end

% R = M(iR);
% B = M(iB);
% C = C(randperm(size(C,1)),:);
t_red = tic;
switch method
	case 'qr'
		[q,r,~] = qr(C(:,1:dE),0);
		C2 = [r q'*C(:,dE+1:end)];
% 		k = find(abs(diag(r)./r(1,1))>1e-10,1,'last'); % rank(r)
	case 'qrs'
		[qc r] = qr(sparse(C(:,1:dE)),sparse(C(:,dE+1:end)),0);
		C2 = full([r qc]);
	case 'qrsp'
		[qc,r,~] = qr(sparse(C(:,1:dE)),sparse(C(:,dE+1:end)),0);
		C2 = full([r qc]);
	case 'lu'
% 		[~,u] = lu(C);
		[l,u,p,~] = lu(sparse(C(:,1:dE)),'vector');
		C2 = full([u l\C(p,dE+1:end)]);
% 		k = min(dE,find(abs(diag(u))./max(abs(diag(u)))>1e-10,1,'last'));
	case 'sym'
		[~,C2] = lu(vpa(C));
% 		k = min(dE,double(rank(C2)));
	case 'rref'
		C2 = rref(C);
	otherwise
		error('Unknown method');
end
t_red = toc(t_red);
red = find(all(abs(C2(:,1:dE))<1e-12,2)); % These rows do not contain excessive monomials
imagesc(abs(double(C2))>1e-12)
fprintf('Eliminated %u equations, %u remaining\n',size(C,1)-numel(red),numel(red));
CR2 = C2(red,dE+1:dE+dR);
CB2 = C2(red,dE+dR+1:end);
% [rank(CR2) dR]

% AA = [CR2 CB2];
% imagesc(AA)
% rref(AA)
% sym(M([iR iB])')


% Even if CR2 is not of full rank, there may be a subset of the basis
% monomials (and corresponding reduction monomials) which can be solved for
% There are different strategies to be tried here.

switch red_elim
	case 'none'
		% Do nothing, only works if CR2 is of full rank (and has m>=n)
		fprintf('size(CR2): [%u %u], rank(CR2): %u\n',size(CR2),rank(CR2));
		
	case 'discard'
		% First, if CR2 is not of full rank, remove the number of basis monomials for which
		% a reduction cannot be found. Which ones to remove are decided using pivoting QR so
		% that CR2\CB2 is as well-conditioned as possible.
		% However, some of the monomials in the basis are themselves the
		% product of the action monomial and a lower-degree monomial in the basis;
		% if such a basis monomial is removed, the lower monomial is no longer mapped
		% to the basis and everything breaks. The simple solution is to remove also the
		% lower monomial, and possibly do this recursively down the chain until everything works.
		% So far I have not found too many examples where this actually produces a correct solution...
		% probably the remaining 'basis' monomials do not usually span the quotient space.
		% Using the QR pivoting to decide which monomials to remove is also quite arbitrary and
		% most likely not optimal, in the sense that there may be another permutation which does
		% produce a valid basis and has acceptable conditioning.

		[q r p] = qr(CR2,'vector');
		k = find(abs(diag(r)./r(1,1))>1e-11,1,'last');
		if abs(r(1,1))<1e-10, k = 0; end

		Rn = R(p(1:k)); % Keep these reduction monomials
		CR2 = r(:,1:k);

		[~,ia] = setdiff(B*act_mon,R(p(k+1:end)));
		Bn = B(ia); % These are the corresponding basis monomials

		% Are there any basis monomials L s.t. act_mon*L is not in B or R?
		for i=1:100
			[~,ia] = intersect(Bn*act_mon,union(Bn,Rn));
			if length(ia)==length(Bn), break; end
			Bn = Bn(ia);
		end

		[~,ia] = intersect(B,Bn);
		CB2 = q'*CB2(:,ia);
		R = Rn;
		B = Bn;

		fprintf('%u reductions available, new basis size after %u rounds: %u\n',k,i,numel(B));
		
	case 'move' % MAYBE NOT WORKING?
		% Another version is to not simply remove the basis monomials, but to move them over to
		% the reduction set instead. This should prevent us from having to go down the chain
		% and allow us to keep more basis monomials.
		% This will be an advanced excercise in array indexing...
% 		CR2, CB2
		for i=1:10
			[q r p] = qr(CR2,'vector');
			k = find(abs(diag(r)./r(1,1))>1e-11,1,'last');
			if abs(r(1,1))<1e-10, k = 0; end
			

			Rn = R(p(1:k)); % Keep these reduction monomials
			CR2 = CR2(:,p(1:k));

			[~,ia] = intersect(B*act_mon,R(p(k+1:end)));
			Bu = B(ia); % These are the basis monomials to move or discard
% 			char(B)
% 			char(Bu)
			% If an 'unselected' basis monomial has no dependent lower degree monomial,
			% it should just be discarded; else, move it to the reduction set.

			% Are there any remaining basis monomials L s.t. act_mon*L is in Bu?
			Bn = setdiff(B,Bu);
			[~,ia] = intersect(Bn*act_mon,Bu);
			Bmove = Bn(ia);
			Bn = setdiff(Bn,Bmove);
			[~,ia] = intersect(B,Bmove);
			CR2 = [CR2 CB2(:,ia)];
			Rn = [Rn; Bmove];
% 			char(Bmove)
			[Bn,ia] = intersect(B,Bn);
			CB2 = CB2(:,ia);
			
			R = Rn;
			B = Bn;
			
% 			disp('Check:')
% 			char(setdiff(B*act_mon,union(B,R)))
			
			fprintf('Moved %u/%u basis monomials to reduction set\n',numel(Bmove),numel(Bu));
			if isempty(Bmove), break; end
			
		end
% 		CR2, CB2
		fprintf('%u reductions available, new basis size after %u rounds: %u\n',k,i,numel(B));
	
		CR2 = r(:,1:k);
		CB2 = q'*CB2;
		

	
	otherwise
		error('Unknown reduction elimination method');
end

% Sanity check
% char(setdiff(B*act_mon,union(B,R)))
% rank(CB2)

switch basis_selection
	case 'none'
		% Do nothing
		
	case 'discard'
		% Just throw away basis monomials that cannot be reduced.
		% This does not check if that has ripple effects on other
		% basis monomials as above, but should usually work.
		[~,r,p] = qr(CR2,'vector');
		bad = abs(diag(r))<1e-10; bad = p(bad);
		Bsel = setdiff(B,R(bad)./act_mon);
		Rsel = setdiff(R,R(bad));
		[~,ia] = intersect(R,Rsel);
		CR2 = CR2(:,ia);
		[~,ia] = intersect(B,Bsel);
		CB2 = CB2(:,ia);
		B = Bsel; R = Rsel;
		
% 	case 'qr' % Martin's QR method, not fully implemented yet. Use old polysolve or fix it...
% 		k = dim;
% 		[q UR] = qr(CR2);
% 		CB2 = q'*CB2;
% 
% 		CP1 = CB2(1:dR,:);
% 		CP2 = CB2(dR+1:end,:);
% 		[~,r,p] = qr(CP2,0);
% 		CPp1 = CP1(:,p(1:end-k));
% 		CB1 = CP1(:,p(end-k+1:end));
% 		UPp2 = r(1:dB-k,1:dB-k);
% 		CB2 = r(1:dB-k,end-k+1:end);
% 		if isempty(CPp1), CPp1 = []; end;
% 		if isempty(UPp2), UPp2= []; end;
% 
% 		CR2 = [UR(1:dR+dB-k,:) [CPp1; UPp2]];
% 		CB2 = [CB1; CB2];
		
	otherwise
		error('Unknown basis selection method');
end


% if rank(CR2)<size(CR2,2), warning('Rank(CR2) = %u < dR = %u',rank(CR2),size(CR2,2)); end
if strcmp(method,'sym')
% 	r = double(rank(CR2));
	r = rank(double(CR2));
	T = -CR2(1:r,:)\CB2(1:r,:);
else
	tic
	T = -CR2\CB2;
	t_sol = toc;
	log10(svd(CR2))'
end
% CR2, CB2

% Construct action matrix
A = zeros(numel(B));
[~,ia,ib] = intersect(act_mon*B,R); % Reduction monomials not in basis
red_ia = ia; red_ib = ib; % save for codegen
for r=1:length(ia)
	A(ia(r),:) = T(ib(r),:);
end
[~,ia,ib] = intersect(act_mon*B,B); % Already in basis
basis_ia = ia; basis_ib = ib;
for r=1:length(ia)
	A(ia(r),ib(r)) = 1;
end
% For codegen, save a sparse matrix with monomial index matchings
S = sparse([red_ia basis_ia],[red_ib+numel(B) basis_ib],1);

% Note that A here is the transpose of the action matrix as usually defined
tic
[v d] = eig(A);
t_eig = toc;
d = diag(d);
[~,ind] = sortrows([real(d) imag(d)]);
evdiff = abs(diff(d(ind)));
fprintf('Smallest diff. between e.v.: %g\n',min(evdiff));
if any(evdiff<1e-6)
	warning('There appear to be eigenvalues of multiplicity > 1');
% 	disp(log10(evdiff))
% 	disp(d(ind))
end

const = B==1;
if nnz(const)==0
	warning('Constant term not in basis');
	s = v;
else
	s = bsxfun(@rdivide,v,v(const,:));
end

% Find variable monomials and assemble solution
[~,bm] = polynomials2matrix(B,'same');
bm = monvec2matrix(bm);
mon_a = monomials(act_mon);
sol_basis = [];
sol = [];
for i=1:n
	ind = find(sum(bm,1)==bm(i,:) & sum(bm,1)~=0); % Find smallest power of x_i
	[~,j] = min(bm(i,ind));
	ind = ind(j);
	if isempty(ind)
		if mon_a(i,1)>0
			sol = [sol; d(:).']; %#ok
			sol_basis = [sol_basis; act_mon]; %#ok
		else
			warning('No power of variable %u in basis',i);
		end
	else
		sol = [sol; s(ind,:)]; %#ok
		sol_basis = [sol_basis; multipol(1,bm(:,ind))]; %#ok
	end
end

info = struct('sol_basis',sol_basis,'B',B,'R',R,'A',A,'T',T,'v',v,'ev',d,'s',s,'C',C,'C2',C2,...
	'red_ia',red_ia,'red_ib',red_ib,'basis_ia',basis_ia,'basis_ib',basis_ib,'dE',dE,'dR',numel(R),'dB',numel(B),'red',red,'S',S);

fprintf('Elimination: %f s, red. solve: %f s, eigendecomp.: %f s\n',t_red,t_sol,t_eig);
% fprintf('Found %u solutions\n',nnz(mean(abs(evaluate(eq,sol)))<1e-6));

